= Practical 5: Interpolation methods for VMS tracks = 

== Introduction ==
Even scaling up from the 'poor' logbook spatial resolution to the more detailed VMS resolution is sometimes not enough for your type of analyses. 
What you rather want to do is to interpolate the fishing tracks from your VMS data and create a number of 'intermediate' points, i.e. interpolated points. 

Before you start to consider to do these type of analyses, you have to be aware of a number of issues. 
  # You are now making up data points
  # You might associate these interpolated points with catches, keep an eye on reality
  # Most often you only want to interpolate between fishing pings, so your analyses of activity is very important!
  # Is your computer up for the test, because you will expand your dataset even more (and requires more memory too)

That should be enough warnings to convince you how cool these things actually are, and please, do try this at home, but be aware of the assumptions when you present something to e.g. stakeholders or a ministry.

== Interpolate VMS data ==
In VMStools we only distinguish between two types of interpolation:
  # Linear interpolation
  # Cubic Hermite Spline interpolation (according to Hintzen et al. 2010, Fisheries Research)

Although the technicalities might be a bit too much for you, the practical way is somewhat simpler. And if you are OK not to watch underneath the hood, you're fine as well.
<code>
>data(tacsat)
#Sort the data and make a subset
>tacsat <- sortTacsat(tacsat)[1:1000,]
>tacsat <- filterTacsat(tacsat,st=c(2,6),hd=NULL,remDup=T)

#Do not mind the large number of arguments here
#Interpolate according to a straight line interpolation
>interpolationSL <- interpolateTacsat(tacsat,interval=120,margin=10,res=100,method="SL",params=list(fm=0.5,distscale=20,sigline=0.2,st=c(2,6)),headingAdjustment=0)

#Interpolate according to the cubic-hermite spline interpolation
>interpolationcHs <- interpolateTacsat(tacsat,interval=120,margin=10,res=100,method="cHs",params=list(fm=0.2,distscale=20,sigline=0.2,st=c(2,6)),headingAdjustment=0)

#The returned interpolation is a list, let's look at the first interpolation
>plot(interpolationSL[[1]][-1,],type="l",xlim=c(3.17,3.24))
>points(interpolationSL[[1]][c(2,101),],pch=19,col="blue")
>lines(interpolationcHs[[1]][-1,],col="red")
</code>
Ok, we've managed to interpolate some of our data. Not in all instances interpolations were possible, as we only got:
<code>
>length(interpolationSL)
>nrow(tacsat)
</code>
216 interpolations while we had 414 tacsat points. In theory (if they are all of the same vessel) we could have had 413 interpolations. 

The format of the interpolation allows some 'lapply' functions to be executed directly on the object, in other cases however, it might be easier to convert the interpolated data back to the default tacsat format.
<code>
>tacsatInt <- interpolation2Tacsat(interpolation,tacsat,npoints=10)
#Each interpolation is splitted into 10 equally spaced points (including the start and the end point). In total 8 new points are added per interpolation.
>nrow(tacsatInt)
>nrow(tacsat)
>(nrow(tacsatInt)-nrow(tacsat))/8 #I've seen that number before

#What is the distance traveled within each of these interpolations?
>sum(distanceInterpolation(interpolationSL))
>sum(distanceInterpolation(interpolationcHs))
</code>
The only way to really test if either of these two interpolations is any better is test it against a much higher resolution dataset.
<code>
#Make use of a 6-minute interval dataset, and subset that every 120 minutes
>data(VMShf)
>colnames(VMShf) <- c("VE_REF","SI_LATI","SI_LONG","SI_SP","SI_HE","SI_DATIM")
>VMShf$VE_COU <- "Atlantis"
>VMShf$SI_DATE<- format(VMShf$SI_DATIM,format="%d/%m/%Y")
>VMShf$SI_TIME<- format(VMShf$SI_DATIM,format="%H:%M")
>VMShf <- formatTacsat(VMShf)
>VMShf <- sortTacsat(VMShf)
>VMShf <- filterTacsat(VMShf,st=c(2,6),hd=NULL,remDup=T)
#cHs first
>cHs <-interpolateTacsat(VMShf,interval=120,margin=10,res=100,method="cHs",params=list(fm=0.2,distscale=20,sigline=0.2,st=c(2,6)),headingAdjustment=1)
#Then straight line
>SL <-interpolateTacsat(VMShf,interval=120,margin=10,res=100,method="SL",params=list(fm=0.2,distscale=20,sigline=0.2,st=c(2,6)),headingAdjustment=1)


#Visualize the results
>plot(diffInter(cHs,VMShf)[,"mean"],pch=19,ylab="difference",ylim=c(0,10))
>abline(h=1,col=2)
>points(diffInter(SL,VMShf)[,"mean"],col="blue",pch=19)
>length(which(diffInter(cHs,VMShf)[,"mean"] < diffInter(SL,VMShf)[,"mean"]))
>sum(diffInter(cHs,VMShf)[,"mean"])
>sum(diffInter(SL,VMShf)[,"mean"])

</code>
Obviously, we could do a bit of tuning here and there to make the performance of the interpolation even better, as this was just a quick and dirty example showing the benefits.

=== Exercise 1 ===
  # Plot the second interpolation, why is the curve so different from the straight line?
  # What is the difference in distance traveled between the two types of interpolation? (try and use the 'distance' function to do it yourself)
  # What would be the associated speed of the vessel under the two different interpolation scenarios?

== From here onwards == 

Once the tacsat data is interpolated some other possibilities remain. It is, for example, possible to add a certain width of a gear to the interpolation. This might be handy when you want to reconstruct trawling tracks as approximately the right scale. Or you could focus on the uncertainty associated with interpolated tracks to test if areas have remained unfished from some time. 

=== Adding gear width to interpolation ===
Especially when your study area is very small (e.g. only a few kilometers), it is worth to start considering the width of the gear in fishing track pictures. One feature tested before was Google Earth pictures where by zooming in, the actual with of the gear could be visualized. As we now move into rather sophisticated tools, I do show some of the underlying tools that are used, but wrapped, inside the functions. 

First of all, select a vessel of which we know the gear width (e.g. a beam trawl has normally speaking twice 12 meter beams).
<code>
>unique(subset(eflalo,LE_GEAR == "TBB"))$VE_REF[1]
>subTacsat <- subset(tacsatp,VE_REF == "238")

#Interpolate the dataset
>cHs <-interpolateTacsat(subTacsat,interval=120,margin=10,res=100,method="cHs",params=list(fm=0.2,distscale=20,sigline=0.2,st=c(2,6)),headingAdjustment=0)

#Make a picture of all interpolations first
#Get the ranges of the total picture
>ranges <- do.call(rbind,lapply(cHs,function(x){return(apply(x[-1,],2,range))}))
>xrange <- range(ranges[,"x"])
>yrange <- range(ranges[,"y"])

>plot(subTacsat$SI_LONG,subTacsat$SI_LATI,xlim=xrange,ylim=yrange,pch=19,col="blue",xlab="Longitude",ylab="Latitude")
>for(iInt in 1:length(cHs)){
  lines(cHs[[iInt]][-1,1],cHs[[iInt]][-1,2])}
</code>
What we now basically would like to do is something close to this:
<code>
>>for(iInt in 1:length(cHs)){
  lines(cHs[[iInt]][-1,1],cHs[[iInt]][-1,2],lwd=2)}
</code>
That did give it more wide gear tracks, but how wide are they really? The total distance from the left hand side of the picture to the right hand side equals aproximately:
<code>
>distance(3.6,51.8,4.5,51.8) #~62km
</code>
Nearly 62 km! So, using a thicker line to plot is not really accurate. Let's do it the 'right' way. 
<code>
>interWidth <- addWidth(cHs,gearWidth=0.024)
>x11(); plot(interWidth); map.axes()
>points(subTacsat$SI_LONG,subTacsat$SI_LATI,col="blue",pch=19)
</code>
Again, you can question how useful this really is if you look at a picture with dimension 60x70km... It would be better to zoom in a bit more and have another look and compare the results with a 'normal' line drawing of R.
<code>
#Let's look at 2km width, how many degrees is that?
>distance(3.6,51.8,3.7,51.8) #0.1 degree longitude = 6.8km, so 1 km is 0.015 degree longitude. 
>distance(3.6,51.8,3.615,51.8)
#In latitude, approx half of that step size
>distance(3.6,51.8,3.6,51.81)
#Take a VMS point and take 100meter on each side of it
>plot(interWidth,ylim=c(51.83098 - (0.0075),51.83098 + (0.0075 )),xlim=c(3.778870 - (0.015),3.778870 + (0.015)))
>points(subTacsat$SI_LONG,subTacsat$SI_LATI,pch=19)
>map.axes()
>for(iInt in 1:length(cHs)){
  lines(cHs[[iInt]][-1,1],cHs[[iInt]][-1,2],col="red")} #The interpolated line only
</code>
What you can see in the picture is the VMS point (the dot), the interpolated line (without gear width, in red) and the interpolated line with gear width in black squares. What happens under the hood is that for each little step taken in the interpolation (each interpolation consists of e.g. 100 small steps i.e. new points), it's bearing is calculated towards the next small step. Having this knowledge, the width of the gear must extend in a perpendicular direction (90 and -90 degrees from the heading of the vessel). Keeping this bearing for a distance equal to the width of the gear gives us the outer points of the black boxes. All black boxes are thereafter combined to give a fishing track. So, the function bearing plays an important role here, you might want to use it for other purposes too.
<code>
>bearing(3.7,51.8,3.6,51.8) #heading into a 270 degree compass course
#If you are interested where you will end up with a certain bearing and distance to travel, you can use this
>distance(3.7,51.8,3.6,51.8) #what distance have I traveled?
>destFromBearing(3.7,51.8,270.0393,6.876387) #starting from the same point, traveling with the bearing and distance calculated, do I end up at the same point?
</code>

=== Calculating uncertainty of interpolation ===